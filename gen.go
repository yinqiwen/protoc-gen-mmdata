package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"strings"

	"github.com/golang/protobuf/protoc-gen-go/descriptor"
)

type Generator struct {
	OutputBuffer         bytes.Buffer
	dumpFileName         string
	macroName            string
	msgTypes             map[string]*descriptor.DescriptorProto
	HashValue            uint64
	keyField, valueField *descriptor.FieldDescriptorProto
}

func (g *Generator) Verify(file *descriptor.FileDescriptorProto) bool {
	g.keyField = nil
	g.valueField = nil
	for _, msg := range file.MessageType {
		var keyField, valueField *descriptor.FieldDescriptorProto
		for _, field := range msg.GetField() {
			if nil != field.GetOptions() {
				opstr := strings.TrimSpace(field.GetOptions().String())
				if opstr == "51234:1" {
					if nil != keyField || nil != g.keyField {
						log.Fatalf("Duplicate filed with option: [(Key) = true]")
						return false
					}
					keyField = field
				} else if opstr == "51235:1" {
					if nil != valueField || nil != g.valueField {
						log.Fatalf("Duplicate filed with option:  [(Value) = true]")
						return false
					}
					valueField = field
				}
			}
		}
		if nil != keyField && nil != valueField {
			g.keyField = keyField
			g.valueField = valueField
		} else if nil != keyField || nil != valueField {
			log.Fatalf("Missing filed with option: [(Key) = true] or [(Value) = true]")
			return false
		}
	}
	if nil == g.keyField || nil == g.valueField {
		//log.Printf("Missing message with fileds with Options [(Key) = true] or [(Value) = true]")
		return false
	}
	return true
}

func (g *Generator) BuildTypeNameMap(file *descriptor.FileDescriptorProto) {
	if nil == g.msgTypes {
		g.msgTypes = make(map[string]*descriptor.DescriptorProto)
	}
	dottedPkg := "." + file.GetPackage()
	for _, msg := range file.MessageType {
		name := dottedPkg + "." + msg.GetName()
		g.msgTypes[name] = msg
		for _, nest := range msg.NestedType {
			g.msgTypes[name+"."+nest.GetName()] = nest
		}
	}
}

func (g *Generator) getDesc(name string) *descriptor.DescriptorProto {
	desc, exist := g.msgTypes[name]
	if exist {
		return desc
	}
	return nil
}

func (g *Generator) DumpFile() {
	ioutil.WriteFile(g.dumpFileName, g.OutputBuffer.Bytes(), 0666)
}

func (g *Generator) TypeName(name string) string {
	if len(name) == 0 {
		return name
	}
	if name[0] == '.' {
		name = name[1:]
	}
	ss := strings.Split(name, ".")
	last := ss[len(ss)-1]
	return last
}

func (g *Generator) DumpHeader(pbfile string) {
	g.dumpFileName = pbfile + ".hpp"
	g.macroName = strings.ToUpper(g.dumpFileName) + "_"
	g.macroName = strings.Replace(g.macroName, ".", "_", -1)
	fmt.Fprintf(&g.OutputBuffer, "// Generated by the plugin protoc-gen-mmadata of protocol buffer compiler.  DO NOT EDIT!\n")
	fmt.Fprintf(&g.OutputBuffer, "//  source: %s\n\n", pbfile)

	fmt.Fprintf(&g.OutputBuffer, "#ifndef %s\n", g.macroName)
	fmt.Fprintf(&g.OutputBuffer, "#define %s\n", g.macroName)
	fmt.Fprintf(&g.OutputBuffer, "#include \"kcfg.hpp\"\n")
	fmt.Fprintf(&g.OutputBuffer, "#include \"mmdata.hpp\"\n")
	fmt.Fprintf(&g.OutputBuffer, "#include \"mmdata_kcfg.hpp\"\n\n")
}

func (g *Generator) Finish() {
	fmt.Fprintf(&g.OutputBuffer, "#endif /* %s */\n", g.macroName)
}

func (g *Generator) DumpNamespaceBegin(name string) (string, []string) {
	ss := strings.Split(name, ".")
	var tabs []string
	tab := ""
	for _, ns := range ss {
		fmt.Fprintf(&g.OutputBuffer, "%snamespace %s\n%s{\n", tab, ns, tab)
		tabs = append(tabs, tab)
		tab = "    " + tab
	}
	return tab, tabs
}

func (g *Generator) DumpNamespaceEnd(tabs []string) {
	for i := len(tabs) - 1; i >= 0; i-- {
		fmt.Fprintf(&g.OutputBuffer, "%s}\n", tabs[i])
	}
}

func (g *Generator) getBaseFieldType(field *descriptor.FieldDescriptorProto) string {
	switch field.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
		return "double"
	case descriptor.FieldDescriptorProto_TYPE_FLOAT:
		return "float"
		// Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
		// negative values are likely.
	case descriptor.FieldDescriptorProto_TYPE_INT64:
		return "int64_t"
	case descriptor.FieldDescriptorProto_TYPE_UINT64:
		return "uint64_tn"
		// Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
		// negative values are likely.
	case descriptor.FieldDescriptorProto_TYPE_INT32:
		return "int32_t"
	case descriptor.FieldDescriptorProto_TYPE_FIXED64:
		return "uint64_t"
	case descriptor.FieldDescriptorProto_TYPE_FIXED32:
		return "uint32_t"
	case descriptor.FieldDescriptorProto_TYPE_BOOL:
		return "bool"
	case descriptor.FieldDescriptorProto_TYPE_STRING:
		return "mmdata::SHMString"
	case descriptor.FieldDescriptorProto_TYPE_BYTES:
		return "mmdata::SHMString"
	case descriptor.FieldDescriptorProto_TYPE_UINT32:
		return "uint32_t"
	case descriptor.FieldDescriptorProto_TYPE_ENUM:
		return field.GetTypeName()
	case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
		return "int32_t"
	case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
		return "int64_t"
	case descriptor.FieldDescriptorProto_TYPE_SINT32:
		return "int32_t"
	case descriptor.FieldDescriptorProto_TYPE_SINT64:
		return "int64_t"
	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
		return g.TypeName(field.GetTypeName())
	default:
		log.Fatalf("Not supported type:%v", field.GetTypeName())
	}
	return ""
}

func (g *Generator) getFieldType(field *descriptor.FieldDescriptorProto) string {
	if field.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REPEATED {
		isMap := false
		buf := &bytes.Buffer{}
		if field.GetType() == descriptor.FieldDescriptorProto_TYPE_MESSAGE {
			desc := g.getDesc(field.GetTypeName())
			if nil != desc && desc.GetOptions().GetMapEntry() {
				keyField, valField := desc.Field[0], desc.Field[1]
				fmt.Fprintf(buf, "mmdata::SHMHashMap<%s, %s>::Type", g.getBaseFieldType(keyField), g.getBaseFieldType(valField))
				isMap = true
			}
		}
		if !isMap {
			fmt.Fprintf(buf, "mmdata::SHMVector<%s>::Type", g.getBaseFieldType(field))
		}
		return buf.String()
	}
	return g.getBaseFieldType(field)
}

func (g *Generator) withDefaultValue(field *descriptor.FieldDescriptorProto) (string, bool) {
	if field.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REPEATED {
		return "", false
	}
	switch field.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
		return "0.0", true
	case descriptor.FieldDescriptorProto_TYPE_FLOAT:
		return "0.0", true
	case descriptor.FieldDescriptorProto_TYPE_INT64:
		return "0", true
	case descriptor.FieldDescriptorProto_TYPE_UINT64:
		return "0", true
	case descriptor.FieldDescriptorProto_TYPE_INT32:
		return "0", true
	case descriptor.FieldDescriptorProto_TYPE_FIXED64:
		return "0", true
	case descriptor.FieldDescriptorProto_TYPE_FIXED32:
		return "0", true
	case descriptor.FieldDescriptorProto_TYPE_BOOL:
		return "false", true
	case descriptor.FieldDescriptorProto_TYPE_STRING:
		return "", false
	case descriptor.FieldDescriptorProto_TYPE_BYTES:
		return "", false
	case descriptor.FieldDescriptorProto_TYPE_UINT32:
		return "", false
	case descriptor.FieldDescriptorProto_TYPE_ENUM:
		return "", false
	case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
		return "0", true
	case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
		return "0", true
	case descriptor.FieldDescriptorProto_TYPE_SINT32:
		return "0", true
	case descriptor.FieldDescriptorProto_TYPE_SINT64:
		return "0", true
	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
		return "0", true
	default:
		log.Fatalf("Not supported type:%v", field.GetTypeName())
	}
	return "", false
}

func (g *Generator) isComplextType(field *descriptor.FieldDescriptorProto) bool {
	if field.GetLabel() == descriptor.FieldDescriptorProto_LABEL_REPEATED {
		return true
	}
	switch field.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
		return false
	case descriptor.FieldDescriptorProto_TYPE_FLOAT:
		return false
	case descriptor.FieldDescriptorProto_TYPE_INT64:
		return false
	case descriptor.FieldDescriptorProto_TYPE_UINT64:
		return false
	case descriptor.FieldDescriptorProto_TYPE_INT32:
		return false
	case descriptor.FieldDescriptorProto_TYPE_FIXED64:
		return false
	case descriptor.FieldDescriptorProto_TYPE_FIXED32:
		return false
	case descriptor.FieldDescriptorProto_TYPE_BOOL:
		return false
	case descriptor.FieldDescriptorProto_TYPE_STRING:
		return true
	case descriptor.FieldDescriptorProto_TYPE_BYTES:
		return true
	case descriptor.FieldDescriptorProto_TYPE_UINT32:
		return false
	case descriptor.FieldDescriptorProto_TYPE_ENUM:
		return false
	case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
		return false
	case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
		return false
	case descriptor.FieldDescriptorProto_TYPE_SINT32:
		return false
	case descriptor.FieldDescriptorProto_TYPE_SINT64:
		return false
	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
		return true
	default:
		log.Fatalf("Not supported type:%v", field.GetTypeName())
	}
	return false
}

func (g *Generator) dumpFieldType(buf *bytes.Buffer, field *descriptor.FieldDescriptorProto) {
	fmt.Fprintf(buf, g.getFieldType(field))
}

func (g *Generator) DumpMessage(msg *descriptor.DescriptorProto, currentTAB string) error {
	buf := &g.OutputBuffer

	tableType := ""
	haveKeyFiled := false
	for _, field := range msg.GetField() {
		if field == g.keyField {
			haveKeyFiled = true
			break
		}
	}
	if haveKeyFiled {
		tableType = fmt.Sprintf("%sTable", msg.GetName())
		fmt.Fprintf(buf, "%sstruct %s;\n", currentTAB, tableType)
	}

	fmt.Fprintf(buf, "%sstruct %s\n", currentTAB, msg.GetName())
	fmt.Fprintf(buf, "%s{\n", currentTAB)
	fieldTab := currentTAB + "    "
	var fields string

	if haveKeyFiled {
		fmt.Fprintf(buf, "%stypedef %s key_type;\n", fieldTab, g.getFieldType(g.keyField))
		fmt.Fprintf(buf, "%stypedef %s value_type;\n", fieldTab, g.getFieldType(g.valueField))
		fmt.Fprintf(buf, "%stypedef %s table_type;\n", fieldTab, tableType)
	}
	for i, field := range msg.GetField() {
		fmt.Fprintf(buf, "%s", fieldTab)
		if field == g.keyField {
			fmt.Fprintf(buf, "key_type")
		} else if field == g.valueField {
			fmt.Fprintf(buf, "value_type")
		} else {
			g.dumpFieldType(buf, field)
		}

		fmt.Fprintf(buf, " %s;\n", field.GetName())
		if i != 0 {
			fields = fields + ","
		}
		fields = fields + field.GetName()
	}
	fmt.Fprintf(buf, "\n%sKCFG_DEFINE_FIELDS(%s)\n", fieldTab, fields)

	//constructor
	fmt.Fprintf(buf, "\n%s%s(const mmdata::CharAllocator& alloc):", fieldTab, msg.GetName())
	firstInitParam := true
	for _, field := range msg.GetField() {
		if g.isComplextType(field) {
			if !firstInitParam {
				fmt.Fprintf(buf, ",")
			}
			fmt.Fprintf(buf, "%s(alloc)", field.GetName())
			firstInitParam = false
		} else {
			defaultInitVal, exist := g.withDefaultValue(field)
			if exist {
				if !firstInitParam {
					fmt.Fprintf(buf, ",")
				}
				fmt.Fprintf(buf, "%s(%s)", field.GetName(), defaultInitVal)
				firstInitParam = false
			}
		}
	}
	fmt.Fprintf(buf, "\n%s{}\n", fieldTab)

	//GetKey/GetValue
	if haveKeyFiled {
		fmt.Fprintf(buf, "\n%sconst key_type& GetKey() const { return %s; }\n", fieldTab, g.keyField.GetName())
		fmt.Fprintf(buf, "%sconst value_type& GetValue() const { return %s; }\n", fieldTab, g.valueField.GetName())
	}

	fmt.Fprintf(buf, "%s};\n", currentTAB)

	if haveKeyFiled {
		currentClass := fmt.Sprintf("%sTable", msg.GetName())
		parentClassType := currentClass + "Parent"
		parentClass := fmt.Sprintf("mmdata::SHMHashMap<%s, %s>::Type", g.getFieldType(g.keyField), g.getFieldType(g.valueField))
		fmt.Fprintf(buf, "%stypedef %s %s;\n", currentTAB, parentClass, parentClassType)
		fmt.Fprintf(buf, "\n%sstruct %s:public %s\n", currentTAB, currentClass, parentClassType)
		fmt.Fprintf(buf, "%s{\n", currentTAB)
		funcTab := currentTAB + "    "
		fmt.Fprintf(buf, "%s%s(const mmdata::CharAllocator& alloc):%s(alloc)\n", funcTab, currentClass, parentClassType)
		fmt.Fprintf(buf, "%s{\n", funcTab)
		fmt.Fprintf(buf, "%s}\n\n", funcTab)
		fmt.Fprintf(buf, "%sstatic uint64_t GetHash() const { return %d;} \n", funcTab, g.HashValue)
		fmt.Fprintf(buf, "%s};\n", currentTAB)
		//fmt.Fprintf(buf, "\n%stypedef mmdata::SHMHashMap<%s, %s>::Type %sTable;\n", currentTAB, g.getFieldType(keyField), g.getFieldType(valueField), msg.GetName())
	}
	return nil
}
